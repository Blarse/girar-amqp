#+OPTIONS: timestamp:nil toc:nil num:nil
#+HTML_HEAD_EXTRA: <style>*{font-size: x-large;}</style>

* Slide 1: intro
Всем привет, меня зовут Игнатов Егор я сотрудник Базальт СПО.
Я расскажу про, то как добавлял в сборочницу поддержку отправки AMQP сообщений.
И про нашу инфраструктуру обмена сообщениями в целом.

* Slide 2: qr
Мой доклад доступен онлайн, так что можете открыть его у себя на устройстве.

* Slide 3: overview
*click*

Думаю большинство присутствующих знакомы с нашей сборочницей, многие
пользовались ей, поэтому перейдем сразу к AMQP

*click*

С AMQP, думаю, знакомо меньше, поэтому в кратце что это.
AMQP расшифровывается как *Advanced Message Queuing Protocol*.
Это RPC протокол для обмена сообщениями в текстовом виде, в данном случае в формате json.

*click*

На википедии говорят, что основными особенностями протокола являюстя:
организация очередей, маршрутизация, надежность и безопасность.

* Slide 4: girar-amqp
*click*

Сборочница написана на bash поэтому в качестве AMQP клиента была
выбрана утилита *amqp-publish* из пакета rabbitmq-c.

В процесс разработки были найдены и исправленны некоторые баги в этой
утилите, а также добавлен новый функционал, в частности это режим
переподключения, если не удалось установить соединение с сервером с
первого раза.

*click*

Сообщение отправляется по событию.

На каждый event отправляется сообщение в формате json, содержащее
соответствующую информацию и мета-данные для дальнейшей обработки
этого сообщения.  Подробнее с форматом сообщений, какие поля они
содержат, можно ознакомится в исходниках, ссылки будут в конце
презентации, а здесь я только расскажу какие события бывают.

* Slide 5: task
Существует 6 событий, касающихся изменения таска:
- *click* state: изменение состояния таска (в целом самый важное событие)
- *click* delete: удаление таска, тот же state под капотом
- *click* deps: изменение зависимостей
- *click* share: изменение доступа к таску
- *click* abort: преждевременная остановка процесса сборки и

То есть все действия с таском, доступные через ssh интерфейс сборочницы.

*click*
И еще есть событие progress, это эксперементальное событие, патч с ним еще не был
добавлен в апстрим, о нем подробнее чуть позже. Сейчас передем к подзаданиям.

* Slide 6: subtask
С сабтасками все аналогично:
- *click* create - на создание
- *click* delete - на удаление
- *click* approve/disapprove - соответственно на добавление апрува или дизапрува
- *click* И также progress

Вот теперь передем к событию progress

* Slide 6: progress
Как я уже сказал этот код еще не добавлен на сборочницу и в нем может что-то поменяться.

Задумка следующая: в процессе сборки задания отправлять промежуточные результаты.
Сборка ведется этапами и на каждый из них отправляется сообщение о
начале и об успешном или не успешном завершении.

*click*
В будущем это позволит сделать поэтапную загрузку таска в базу, по
мере готовности данных, *click* а также проводить анализ процесса сборки ...

*click*
*click*
Ниже показан кусок кода girar со всеми стадиями сборки

* Slide 8: acl
Ну и события связанные с ACL
На каждое изменение acl отправляется сообщение с именем репозитория в котором произошло
изменение, таргетом: это пакет или группа которая изменяется, список старых и
список новых владельцев.
*click*
Вот все возможные event'ы с acl:
- add
- del
- leader
- replace
И 2 суперпользовательских:
- create
- delete


* Slide 9: RabbitMQ
Передем ко второй части доклада - RabbitMQ
*click*
Мы выбрали RabbitMQ в качестве брокера потому что наиболее широко
распространенный брокер сообщений с открытым исходным кодом, он
активно развивается и имеет очень хорошую документацию

Подробно о том как работает сам брокер вы можете ознакомится
самостоятельно, я опять же рекомендую оффициальную документацию, там
есть множество подробных примеров использования на разных языках
программирования, я расскажу только особенности нашего случая.

*click* ha
Так как брокер - это ключевой компонент, от него требуется быть
надежным, либо как еще говорят высоко доступным (High Available)

*click*
Для этого у нас развернут кластер из трех нод(узлов) средствами RabbitMQ.

*click*
Для клиентов, которые напрямую не поддерживают работу с кластером
напрямую, то есть, которые работают только с одним сервером, настроен
виртуальный ip и keepalived для автоматического перехода ip на другой
ресурс.

*click*
В кластере из трех и более узлов можно создать так называемые quorum
очереди, которые автоматически зеркалируют сообщения между всеми
нодами кластера, что также обеспечивает надежность в работе системы.
Так например отправлять сообщения можно на одну машину, а забирать с
другой.

*click* security
Другой важный аспект - это безопасность для этого,

*click*
Во-первых, все подключения к серверу осуществляются через TLS.
*click*
Во-вторых, разграничен доступ к ресурсам у отдельных полозователей.
*click*
А также был реалезован отдельный сервер аутентификации и авторизации,
с поддержкой авторизации по source ip.

* Slide 12: Services
Теперь передем к сервисам, котрые используют полученные сообщения

* Slide 13: repodb

На данный момент основным приложением является загрузка данных в базу repodb.
Поэтому сначал я немного рассакжу про работу моих коллег, связанную с этой базой.

Первый проект altrepodb - это загрузчик базы данных из разных
источников, в том числе со сборочницы, багзиллы

структура базы описанна вот в этом файле, ссылка на исходники будет в конце презентации.

Второй - altrepo-api - это публичное API к базе данных repodb
посмотреть и попробовать его можно по этой ссылке.

Ну и третий - это сайт https://packages.altlinux.org/ , который визуализирует данные из базы

* Slide 14: Task Loader

Данный сервис, находится в стадии активной разработки и решает две
основные задачи, это:
*поддержание актуальности базы*: загрузка данных происходит сразу при получении
сообщения
Обработка событий, которые сложно отследить по состоянию файловой системы сборочницы:

например при удалении таска сборочница полностью стирает папку задания
с файловой системы и без сообщения отследить удаление пакета не просто.

* Slide 15: bugzilla
Помимо girar, сообщения еще отправляются из нашей
багзиллы(bugzilla.altlinux.org), для этого используется плагин
Bugzilla-Push, доработанный под наши требования

Нынешняя структура базы не позволяет грузить всю информациию,
получаемою из сообщения, поэтому в будущем планируется изменить
структуру и сделать сервис по загрузке.


* Slide 16: qa
Также AMQP сообщения используются в процессах тестирования.

Подробности о самом процессе тестирования сборочных заданий можно
будет узнать завтра утром из докладов моих коллег тестировщиков.

В докладе этого не будет, потому что функционал был добавлен совсем
недавно, но могу сказать что сейчас уже информация об изменении
в таске приходит от сборочницы через AMQP.

