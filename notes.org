#+OPTIONS: timestamp:nil toc:nil num:nil
#+HTML_HEAD_EXTRA: <style>*{font-size: x-large;}</style>

* Slide 1: intro
Всем привет, меня зовут Игнатов Егор я сотрудник Базальт СПО.
Я расскажу про, то как добавлял в сборочницу поддержку отправки AMQP сообщений.
И про нашу инфраструктуру обмена сообщениями в целом.

* Slide 2: qr
Мой доклад доступен онлайн, так что можете открыть его у себя на устройстве.

* Slide 3: overview
*<click>*

Думаю большинство присутствующих знакомы с нашей сборочницей она же girar, многие
пользовались ей, поэтому перейдем сразу к AMQP

*<click>*

С AMQP, думаю, знакомо меньше, поэтому в кратце что это.
AMQP расшифровывается как *Advanced Message Queuing Protocol*.
Это RPC протокол для обмена сообщениями в текстовом виде, в данном случае в формате json.

*<click>*

На википедии говорят, что основными особенностями протокола являюстя:
организация очередей, маршрутизация, надежность и безопасность.

* Slide 4: girar-amqp
AMQP в Сборочнице

*<click>*

Сборочница написана на bash поэтому в качестве AMQP клиента была
выбрана утилита *amqp-publish* из пакета rabbitmq-c.

В процесс разработки были найдены и исправленны некоторые баги в этой
утилите, а также добавлен новый функционал, в частности это режим
переподключения, если не удалось установить соединение с сервером с
первого раза.

*<click>*

Сообщение отправляется по событию.

На каждое событие отправляется сообщение в формате json, содержащее
соответствующую информацию и мета-данные для дальнейшей обработки
этого сообщения.  Подробнее с форматом сообщений, какие json поля они
содержат, можно ознакомится в исходниках, ссылки будут в конце
презентации, а здесь я только расскажу какие события бывают.

* Slide 5: task
Существует 6 событий, касающихся изменения таска:
- *<click>* state: изменение состояния таска (в целом самый важное событие)
- *<click>* delete: удаление таска, тот же state под капотом
- *<click>* deps: изменение зависимостей
- *<click>* share: изменение доступа к таску
- *<click>* abort: преждевременная остановка процесса сборки

То есть все действия с таском, доступные через ssh интерфейс
сборочницы, хотя state меняется и в процессе сборки тоже.

*<click>*
И еще есть событие *progress*, это эксперементальное событие, патч с ним еще не был
добавлен в апстрим, о нем подробнее чуть позже. Сейчас передем к подзаданиям.

* Slide 6: subtask
С подзаданиями(сабтасками) все аналогично:
- *<click>* create - на создание
- *<click>* delete - на удаление
- *<click>* approve/disapprove - соответственно на добавление апрува или дизапрува
- *<click>* И также progress

* Slide 6: progress
Вот теперь передем к событию progress

Как я уже сказал этот код еще не добавлен на сборочницу и в нем может
что-то поменяться.  Задумка следующая: Поскольку сборка ведется
этапами, то в процессе сборки можно отправлять сообщения о начале и об
успешном или не успешном завершении каждого из этапов.

*<click>* В будущем это позволит сделать поэтапную загрузку информации
о таске в базу данных, по мере готовности этих данных, что уменьшит
общую задержку при загрузке, увеличит актуальность данных и даст
возможность отслеживать процесс сборки в реальном времени сторонним
приложениям.

*<click>* а также позволит проводить анализ процесса сборки: например отследить
время прошлых сборок и проверок каждого пакета и расчитать примерное
время сборки всего задания

*<click>*
*<click>*
Ниже показан кусок кода girar со всеми стадиями сборки, вот как раз
именно их и планируется отслеживать. Кому интересно файл
gb/gb-build-task-stages в проекте girar

* Slide 8: acl
Ну и третий тип событий, события связанные с ACL
На каждое изменение acl отправляется сообщение с именем ветки
репозитория в которой произошло изменение, таргетом: это пакет или
группа которая изменяется и список старых и новых владельцев.
*<click>*
Вот все возможные event'ы с acl:
- add
- del
- leader
- replace
И 2 суперпользовательских:
- create
- delete


* Slide 9: RabbitMQ
Передем ко второй части доклада - RabbitMQ

Мы выбрали RabbitMQ в качестве брокера потому что это наиболее широко
распространенный брокер сообщений с открытым исходным кодом, он
активно развивается и имеет очень хорошую документацию

Подробно о том как работает сам брокер вы можете ознакомится
самостоятельно, я опять же рекомендую оффициальную документацию, там
есть множество примеров использования на разных языках
программирования, я расскажу только особенности нашего случая.

*<click>* ha

Так как брокер - это ключевой компонент, от него требуется быть
надежным, и как еще говорят высоко доступным (High Available)

*<click>*

Для этого у нас развернут кластер из трех нод(узлов) средствами RabbitMQ.

*<click>*

Для клиентов, которые напрямую не поддерживают работу с кластером
напрямую, то есть, которые работают только с одним сервером, настроен
виртуальный ip и keepalived для автоматического перехода ip на другой
ресурс.

*<click>*
А также используются так называемые quorum очереди, которые
автоматически зеркалируют сообщения между всеми нодами кластера, что
также обеспечивает надежность в работе системы.  Так например
сообщение, отправленное на один узел кластера, можно получить с
другого. Вся синхронизация происходит автоматически самим RabbitMQ

*<click>* security

Другой важный аспект - это безопасность для этого,

*<click>*

Во-первых, все подключения к серверу осуществляются через TLS.

*<click>*

Во-вторых, разграничен доступ к ресурсам у отдельных полозователей.
Для каждого клиента создан свой пользователь, который имеет доступ
только к нужным ему ресурсам.

*<click>*

А также был реалезован отдельный сервер аутентификации и авторизации,
*<click>* с поддержкой авторизации по source ip, поскольку такой
функционал отсутствует во встроенном решении.

* Slide 12: Services
Теперь передем к сервисам, котрые подписываются на очередь и
обрабатывают полученные сообщения

* Slide 13: repodb

На данный момент основным приложением является загрузка данных в базу repodb.
Поэтому сначал я немного рассакжу про работу моих коллег, связанную с этой базой.

repodb - это база данных clickhouse которая хранит в себе различную
информацию касающуюся проекта ALT Linux, такую как состояние веток
репозитория, состояния сборочных заданий, образы дистрибутивов, баги
из багзиллы и прочее.

*<click>*

Первый проект altrepodb - это загрузчик базы данных.
Он наполняет ее с разных источников с файловой системы,  ... TODO...

*<click>*

структура базы описанна вот в этом файле, ссылка ссылка тоже будет в конце презентации

*<click>*

Второй проект - altrepo-api - это публичное API к базе данных repodb
посмотреть и попробовать его можно по этой ссылке. *<click>*

*<click>*

Ну и третий - это сайт https://packages.altlinux.org/, который визуализирует данные repodb

* Slide 14: Services
** task loader
Сервис загрузки информации о тасках, он находится в стадии активной
разработки и решает две основные задачи, это:

*<click>*

*поддержание актуальности базы*: загрузка данных происходит сразу при получении
сообщения

*<click>*

Обработка событий, которые сложно отследить по состоянию файловой системы:
например при удалении таска сборочница полностью стирает папку задания
с файловой системы и без сообщения отследить удаление задания не просто.

*<click>*

Для подключения к серверу RabbitMQ используется библиотека *pika*

** bugzilla
Помимо girar, сообщения еще отправляются из нашей
багзиллы(bugzilla.altlinux.org), *<click>* для этого используется
плагин Bugzilla-Push, доработанный под наши требования

К сожалению нынешняя структура базы не позволяет грузить всю информациию,
получаемую из сообщения, поэтому в будущем планируется изменить
структуру и сделать сервис по загрузке.

** qa
Также AMQP сообщения используются в процессах тестирования сборочных заданий.

Подробности о самом процессе тестирования можно будет узнать завтра
утром из докладов моих коллег тестировщиков.

В докладе этого не будет, потому что функционал был добавлен совсем
недавно, но могу сказать что сейчас уже информация об изменении
в таске приходит от сборочницы через AMQP.

* end
спасибо за внимание
